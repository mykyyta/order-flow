# Стратегія розвитку ядра та перехід до Hexagonal + DDD (станом на 2026-02-07)

## Мета
Зберегти працездатне ядро, мінімізувати регресії та підготувати систему до масштабування функцій управління й обліку. Пріоритет — контрольований рефакторинг із чітким розмежуванням відповідальностей (DDD), і портами/адаптерами (hexagonal).

## Вихідні умови
- Поточний моноліт Django з одним доменним контуром `orders`.
- Бізнес-логіка зосереджена у `views.py`.
- Існує інтеграція Telegram, нотифікації, обробка статусів.
- Є технічний борг і слабкі тестові опори.

## Принципи, які беремо за основу
1. **Ядро домену відокремлюється від фреймворку**: доменні сервіси не залежать від Django.
2. **Порти та адаптери**: інфраструктура (БД, Telegram, HTTP) – це адаптери, ядро — інваріантне.
3. **Strangler-підхід**: поступове винесення логіки без «великого вибуху».
4. **Тестові опори до перетворень**: регресійні тести перед ключовими змінами.

## Доменно-орієнтована картина (пропозиція)
### Об’єкти домену (ядро)
- **Order** (замовлення)
- **OrderStatus** (стан замовлення)
- **OrderStatusHistory** (історія станів)
- **ProductModel**, **Color** (довідники)
- **NotificationPreference** (налаштування нотифікацій)

### Доменні сервіси
- `OrderService`: створення замовлення, зміна статусу, контроль інваріантів.
- `NotificationService`: формування повідомлень, правила відкладення/пауза.
- `CatalogService`: управління моделями й кольорами.

### Порти (інтерфейси)
- `OrderRepository` (збереження/читання)
- `NotificationSender` (Telegram та інші канали)
- `Clock` (ін’єкція часу для тестів)

### Адаптери
- Django ORM репозиторії
- Telegram API адаптер
- HTTP контролери Django (views)
- Management commands/cron для відкладених нотифікацій

## Порядок реалізації (етапи)

### Етап 0. Стабілізація і контроль ризиків (короткий)
**Ціль:** заморозити регресії.
- Додати мінімальні тести на:
  - створення замовлення,
  - зміну статусу,
  - відкладені нотифікації.
- Підготувати базову мапу процесів (референс-діаграма).

### Етап 1. Виділення доменної логіки
**Ціль:** винести бізнес-логіку з Django views.
- Створити модуль `domain/` або `core/` (без залежності від Django).
- Описати доменні сутності (мінімально) і сервіси.
- Інваріанти:
  - `finished_at` залежить від статусу,
  - статус не може перескакувати через заборонені переходи (якщо потрібно).

### Етап 2. Інтерфейсні порти і адаптери
**Ціль:** роз’єднати ядро і зовнішній світ.
- Описати інтерфейси `OrderRepository`, `NotificationSender`, `Clock`.
- Реалізувати Django ORM адаптер.
- Винести Telegram інтеграцію в адаптер.

### Етап 3. Strangler-перехід у контролерах
**Ціль:** перенести логіку в сервіси, залишаючи HTTP-API стабільним.
- View → виклик доменного сервісу.
- Поступове видалення дублюючого коду.
- Рефакторинг шаблонів за необхідності.

### Етап 4. Винесення нотифікацій у фон
**Ціль:** надійність та масштабованість.
- Перетворити `send_delayed_notifications` в management command.
- Запуск через cron/Celery/APS.
- Логувати всі відправки й причини пропуску.

### Етап 5. Рефакторинг моделі даних
**Ціль:** доменна чистота й оптимізація.
- Розглянути фіксацію `Order.current_status` як поле (щоб уникнути N+1), синхронізоване з історією.
- Запровадити транзакційні методи зміни статусу.
- Оптимізувати запити для списків.

## Архітектурна структура (приклад)
```
orders/
  domain/
    entities.py
    services.py
    ports.py
  adapters/
    repositories.py
    notifications.py
    clock.py
  web/
    views.py
    forms.py
    urls.py
```

## Критерії успіху
- Більшість бізнес-логіки — у `domain/`.
- Views не містять бізнес-умов і правил.
- Тести покривають основні сценарії зміни статусів і нотифікацій.
- Нотифікації винесені у фон.

## Ризики і як їх зняти
- **Ризик регресій** → захист мінімальними інтеграційними тестами + sandbox реліз.
- **Ризик зламу інтеграцій** → адаптери з контрактними тестами.
- **Ризик розростання техборгу** → заборона прямої бізнес-логіки у views.

## Орієнтовний порядок задач у коді
1. Додати доменний `OrderService` з методами `create_order`, `change_status`.
2. Витягти нотифікаційні правила в `NotificationService`.
3. Ввести порти та підключити їх у views.
4. Створити ORM-репозиторій і адаптер Telegram.
5. Створити management command для відкладених нотифікацій.
6. Оптимізувати модель статусів/історії (за потреби).

---

Якщо хочеш, можу підготувати:
- чіткий backlog із задачами та оцінками (дні/тижні),
- рішення щодо переходу на `Order.current_status`,
- список тестів і їх пріоритет.
