# Generated by Django 5.1.6 on 2026-02-14 16:04

from django.db import migrations, models
from django.db.models import Q


def _infer_single_unit(*, values: list[str]) -> str | None:
    units = sorted({u for u in values if u})
    if len(units) == 1:
        return units[0]
    if len(units) > 1:
        raise RuntimeError(f"Multiple units found: {units}")
    return None


def forward_fill_material_stock_unit(apps, schema_editor) -> None:
    Material = apps.get_model("materials", "Material")
    MaterialStock = apps.get_model("materials", "MaterialStock")
    PurchaseOrderLine = apps.get_model("materials", "PurchaseOrderLine")
    SupplierMaterialOffer = apps.get_model("materials", "SupplierMaterialOffer")

    # Conservative fallback. If a material is unused (no stock, no orders, no offers),
    # we still need a non-null value to enforce the new constraint.
    fallback_unit = "pcs"

    materials = Material.objects.filter(Q(stock_unit__isnull=True) | Q(stock_unit="")).only("id", "stock_unit")
    for material in materials.iterator():
        # 1) Prefer stock unit if it exists and is unambiguous.
        stock_units = list(
            MaterialStock.objects.filter(material_id=material.id)
            .values_list("unit", flat=True)
            .distinct()
        )
        try:
            unit = _infer_single_unit(values=stock_units)
        except RuntimeError as exc:
            raise RuntimeError(
                f"Material #{material.id} has multiple units in stock records. "
                "Unify units before applying this migration."
            ) from exc
        if unit:
            Material.objects.filter(id=material.id).update(stock_unit=unit)
            continue

        # 2) Fallback to purchase order lines unit if unambiguous.
        po_units = list(
            PurchaseOrderLine.objects.filter(material_id=material.id)
            .values_list("unit", flat=True)
            .distinct()
        )
        try:
            unit = _infer_single_unit(values=po_units)
        except RuntimeError as exc:
            raise RuntimeError(
                f"Material #{material.id} has multiple units in purchase orders. "
                "Unify units before applying this migration."
            ) from exc
        if unit:
            Material.objects.filter(id=material.id).update(stock_unit=unit)
            continue

        # 3) Fallback to supplier offers unit if unambiguous.
        offer_units = list(
            SupplierMaterialOffer.objects.filter(material_id=material.id)
            .values_list("unit", flat=True)
            .distinct()
        )
        try:
            unit = _infer_single_unit(values=offer_units)
        except RuntimeError as exc:
            raise RuntimeError(
                f"Material #{material.id} has multiple units in supplier offers. "
                "Unify units before applying this migration."
            ) from exc
        if unit:
            Material.objects.filter(id=material.id).update(stock_unit=unit)
            continue

        Material.objects.filter(id=material.id).update(stock_unit=fallback_unit)


class Migration(migrations.Migration):

    dependencies = [
        ("materials", "0004_material_stock_unit"),
    ]

    operations = [
        migrations.RunPython(forward_fill_material_stock_unit, migrations.RunPython.noop),
        migrations.AlterField(
            model_name="material",
            name="stock_unit",
            field=models.CharField(
                choices=[("pcs", "шт"), ("m", "м"), ("m2", "м²"), ("g", "г"), ("ml", "мл")],
                help_text="Одиниця обліку на складі.",
                max_length=8,
            ),
        ),
    ]

